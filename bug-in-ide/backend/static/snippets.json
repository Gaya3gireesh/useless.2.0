[
  {
    "language": "javascript",
    "filename": "user-manager.js",
    "lines": [
      "class UserManager {",
      "  constructor() {",
      "    this.users = [];",
      "    this.activeUser = null;",
      "  }",
      "",
      "  addUser(name, email) {",
      "    if (!name || !email) {",
      "      throw new Error('Name and email required');",
      "    }",
      "    const user = { name, email, id: Date.now() };",
      "    this.users.push(user);",
      "    return user;",
      "  }",
      "",
      "  findUser(id) {",
      "    return this.users.find(user => user.id === id);",
      "  }",
      "",
      "  deleteUser(id) {",
      "    const index = this.users.findIndex(user => user.id = id);",
      "    if (index !== -1) {",
      "      this.users.splice(index, 1);",
      "      return true;",
      "    }",
      "    return false;",
      "  }",
      "}"
    ]
  },
  {
    "language": "python",
    "filename": "data_processor.py",
    "lines": [
      "import json",
      "import csv",
      "from datetime import datetime",
      "",
      "class DataProcessor:",
      "    def __init__(self, file_path):",
      "        self.file_path = file_path",
      "        self.data = []",
      "",
      "    def load_data(self):",
      "        try:",
      "            with open(self.file_path, 'r') as file:",
      "                self.data = json.load(file)",
      "        except FileNotFoundError:",
      "            print(f'File {self.file_path} not found')",
      "            return False",
      "",
      "    def process_records(self):",
      "        processed = []",
      "        for record in self.data:",
      "            if record.get('status') == 'active':",
      "                record['processed_at'] = datetime.now().isoformat()",
      "                processed.append(record)",
      "        return processed",
      "",
      "    def save_results(self, output_path):",
      "        with open(output_path, 'w') as file",
      "            json.dump(self.processed_data, file, indent=2)"
    ]
  },
  {
    "language": "javascript",
    "filename": "api-client.js",
    "lines": [
      "const API_BASE_URL = 'https://api.example.com';",
      "",
      "class ApiClient {",
      "  constructor(apiKey) {",
      "    this.apiKey = apiKey;",
      "    this.headers = {",
      "      'Content-Type': 'application/json',",
      "      'Authorization': `Bearer ${apiKey}`",
      "    };",
      "  }",
      "",
      "  async get(endpoint) {",
      "    const response = await fetch(`${API_BASE_URL}${endpoint}`, {",
      "      method: 'GET',",
      "      headers: this.headers",
      "    });",
      "    return response.json();",
      "  }",
      "",
      "  async post(endpoint, data) {",
      "    const response = await fetch(`${API_BASE_URL}${endpoint}`, {",
      "      method: 'POST',",
      "      headers: this.headers,",
      "      body: JSON.stringify(data)",
      "    });",
      "    if (!response.ok) {",
      "      throw new Error(`HTTP error! status: ${response.status}`);",
      "    }",
      "    return response.json();",
      "  }",
      "",
      "  async delete(endpoint) {",
      "    const response = await fetch(`${API_BASE_URL}${endpoint}` {",
      "      method: 'DELETE',",
      "      headers: this.headers",
      "    });",
      "    return response.ok;",
      "  }",
      "}"
    ]
  },
  {
    "language": "python",
    "filename": "calculator.py",
    "lines": [
      "class Calculator:",
      "    def __init__(self):",
      "        self.history = []",
      "",
      "    def add(self, a, b):",
      "        result = a + b",
      "        self.history.append(f'{a} + {b} = {result}')",
      "        return result",
      "",
      "    def subtract(self, a, b):",
      "        result = a - b",
      "        self.history.append(f'{a} - {b} = {result}')",
      "        return result",
      "",
      "    def multiply(self, a, b):",
      "        result = a * b",
      "        self.history.append(f'{a} * {b} = {result}')",
      "        return result",
      "",
      "    def divide(self, a, b):",
      "        if b == 0:",
      "            raise ValueError('Cannot divide by zero')",
      "        result = a / b",
      "        self.history.append(f'{a} / {b} = {result}')",
      "        return result",
      "",
      "    def get_history(self):",
      "        return self.history",
      "",
      "    def clear_history(self):",
      "        self.history = []",
      "",
      "def main():",
      "    calc = Calculator()",
      "    result = calc.add(10, 5)",
      "    print(f'Result: {result}')",
      "",
      "if __name__ == '__main__'",
      "    main()"
    ]
  },
  {
    "language": "javascript",
    "filename": "todo-list.js",
    "lines": [
      "class TodoList {",
      "  constructor() {",
      "    this.todos = [];",
      "    this.nextId = 1;",
      "  }",
      "",
      "  addTodo(text) {",
      "    const todo = {",
      "      id: this.nextId++,",
      "      text: text,",
      "      completed: false,",
      "      createdAt: new Date()",
      "    };",
      "    this.todos.push(todo);",
      "    return todo;",
      "  }",
      "",
      "  toggleTodo(id) {",
      "    const todo = this.todos.find(t => t.id === id);",
      "    if (todo) {",
      "      todo.completed = !todo.completed;",
      "    }",
      "    return todo;",
      "  }",
      "",
      "  deleteTodo(id) {",
      "    const index = this.todos.findIndex(t => t.id === id);",
      "    if (index > -1) {",
      "      return this.todos.splice(index, 1)[0];",
      "    }",
      "    return null;",
      "  }",
      "",
      "  getCompletedTodos() {",
      "    return this.todos.filter(todo => todo.completed === true);",
      "  }",
      "",
      "  getPendingTodos() {",
      "    return this.todos.filter(todo => todo.completed == false);",
      "  }",
      "}"
    ]
  },
  {
    "language": "python",
    "filename": "file_manager.py",
    "lines": [
      "import os",
      "import shutil",
      "from pathlib import Path",
      "",
      "class FileManager:",
      "    def __init__(self, base_path):",
      "        self.base_path = Path(base_path)",
      "        self.ensure_directory_exists()",
      "",
      "    def ensure_directory_exists(self):",
      "        if not self.base_path.exists():",
      "            self.base_path.mkdir(parents=True, exist_ok=True)",
      "",
      "    def create_file(self, filename, content=''):",
      "        file_path = self.base_path / filename",
      "        with open(file_path, 'w') as file:",
      "            file.write(content)",
      "        return file_path",
      "",
      "    def read_file(self, filename):",
      "        file_path = self.base_path / filename",
      "        if file_path.exists():",
      "            with open(file_path, 'r') as file:",
      "                return file.read()",
      "        return None",
      "",
      "    def delete_file(self, filename):",
      "        file_path = self.base_path / filename",
      "        if file_path.exists():",
      "            file_path.unlink()",
      "            return True",
      "        return False",
      "",
      "    def list_files(self):",
      "        return [f.name for f in self.base_path.iterdir() if f.is_file()]",
      "",
      "    def copy_file(self, source, destination):",
      "        src_path = self.base_path / source",
      "        dest_path = self.base_path / destination",
      "        if src_path.exists():",
      "            shutil.copy2(src_path, dest_path)",
      "            return True",
      "        return False"
    ]
  },
  {
    "language": "javascript",
    "filename": "event-handler.js",
    "lines": [
      "class EventHandler {",
      "  constructor() {",
      "    this.listeners = new Map();",
      "  }",
      "",
      "  addEventListener(event, callback) {",
      "    if (!this.listeners.has(event)) {",
      "      this.listeners.set(event, []);",
      "    }",
      "    this.listeners.get(event).push(callback);",
      "  }",
      "",
      "  removeEventListener(event, callback) {",
      "    if (this.listeners.has(event)) {",
      "      const callbacks = this.listeners.get(event);",
      "      const index = callbacks.indexOf(callback);",
      "      if (index !== -1) {",
      "        callbacks.splice(index, 1);",
      "      }",
      "    }",
      "  }",
      "",
      "  emit(event, data) {",
      "    if (this.listeners.has(event)) {",
      "      const callbacks = this.listeners.get(event);",
      "      callbacks.forEach(callback => {",
      "        try {",
      "          callback(data);",
      "        } catch (error) {",
      "          console.error(`Error in event listener for ${event}:`, error);",
      "        }",
      "      });",
      "    }",
      "  }",
      "",
      "  removeAllListeners(event) {",
      "    if (event) {",
      "      this.listeners.delete(event);",
      "    } else {",
      "      this.listeners.clear();",
      "    }",
      "  }",
      "",
      "  getListenerCount(event) {",
      "    return this.listeners.has(event) ? this.listeners.get(event).length : 0;",
      "  }",
      "}"
    ]
  },
  {
    "language": "python",
    "filename": "database.py",
    "lines": [
      "import sqlite3",
      "from datetime import datetime",
      "",
      "class Database:",
      "    def __init__(self, db_path):",
      "        self.db_path = db_path",
      "        self.connection = None",
      "        self.connect()",
      "",
      "    def connect(self):",
      "        try:",
      "            self.connection = sqlite3.connect(self.db_path)",
      "            self.connection.row_factory = sqlite3.Row",
      "        except sqlite3.Error as e:",
      "            print(f'Database connection error: {e}')",
      "",
      "    def execute_query(self, query, params=None):",
      "        cursor = self.connection.cursor()",
      "        try:",
      "            if params:",
      "                cursor.execute(query, params)",
      "            else:",
      "                cursor.execute(query)",
      "            self.connection.commit()",
      "            return cursor.fetchall()",
      "        except sqlite3.Error as e:",
      "            print(f'Query execution error: {e}')",
      "            self.connection.rollback()",
      "            return None",
      "",
      "    def create_table(self, table_name, columns):",
      "        query = f'CREATE TABLE IF NOT EXISTS {table_name} ({columns})'",
      "        return self.execute_query(query)",
      "",
      "    def insert_record(self, table, data):",
      "        columns = ', '.join(data.keys())",
      "        placeholders = ', '.join(['?' * len(data)])",
      "        query = f'INSERT INTO {table} ({columns}) VALUES ({placeholders})'",
      "        return self.execute_query(query, list(data.values()))",
      "",
      "    def close(self):",
      "        if self.connection:",
      "            self.connection.close()"
    ]
  },
  {
    "language": "javascript",
    "filename": "validation.js",
    "lines": [
      "class Validator {",
      "  static isEmail(email) {",
      "    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;",
      "    return emailRegex.test(email);",
      "  }",
      "",
      "  static isPhoneNumber(phone) {",
      "    const phoneRegex = /^\\+?[1-9]\\d{1,14}$/;",
      "    return phoneRegex.test(phone);",
      "  }",
      "",
      "  static isStrongPassword(password) {",
      "    if (password.length < 8) {",
      "      return false;",
      "    }",
      "    const hasUppercase = /[A-Z]/.test(password);",
      "    const hasLowercase = /[a-z]/.test(password);",
      "    const hasNumbers = /\\d/.test(password);",
      "    const hasSpecialChar = /[!@#$%^&*]/.test(password);",
      "    return hasUppercase && hasLowercase && hasNumbers && hasSpecialChar;",
      "  }",
      "",
      "  static isValidURL(url) {",
      "    try {",
      "      new URL(url);",
      "      return true;",
      "    } catch {",
      "      return false;",
      "    }",
      "  }",
      "",
      "  static validateForm(formData) {",
      "    const errors = [];",
      "    if (!formData.name || formData.name.trim() === '') {",
      "      errors.push('Name is required');",
      "    }",
      "    if (!this.isEmail(formData.email)) {",
      "      errors.push('Valid email is required');",
      "    }",
      "    if (!this.isStrongPassword(formData.password)) {",
      "      errors.push('Password must be strong');",
      "    }",
      "    return errors.length === 0 ? null : errors;",
      "  }",
      "}"
    ]
  },
  {
    "language": "python",
    "filename": "config_manager.py",
    "lines": [
      "import json",
      "import os",
      "from typing import Dict, Any",
      "",
      "class ConfigManager:",
      "    def __init__(self, config_file='config.json'):",
      "        self.config_file = config_file",
      "        self.config = {}",
      "        self.load_config()",
      "",
      "    def load_config(self):",
      "        if os.path.exists(self.config_file):",
      "            try:",
      "                with open(self.config_file, 'r') as file:",
      "                    self.config = json.load(file)",
      "            except json.JSONDecodeError as e:",
      "                print(f'Error loading config: {e}')",
      "                self.config = {}",
      "        else:",
      "            self.create_default_config()",
      "",
      "    def create_default_config(self):",
      "        self.config = {",
      "            'debug': False,",
      "            'database_url': 'sqlite:///app.db',",
      "            'secret_key': 'your-secret-key',",
      "            'port': 8000",
      "        }",
      "        self.save_config()",
      "",
      "    def get(self, key: str, default=None):",
      "        return self.config.get(key, default)",
      "",
      "    def set(self, key: str, value: Any):",
      "        self.config[key] = value",
      "",
      "    def save_config(self):",
      "        try:",
      "            with open(self.config_file, 'w') as file:",
      "                json.dump(self.config, file, indent=4)",
      "        except IOError as e:",
      "            print(f'Error saving config: {e}')",
      "",
      "    def update_config(self, updates: Dict[str, Any]):",
      "        self.config.update(updates)",
      "        self.save_config()",
      "",
      "    def reset_to_default(self):",
      "        if os.path.exists(self.config_file):",
      "            os.remove(self.config_file)",
      "        self.create_default_config()"
    ]
  }
]
